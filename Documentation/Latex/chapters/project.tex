\section{Project Stage}
\subsection{System Architecture}

%\begin{figure}[H]
%	\centering
%	\includegraphics[width=\textwidth]{img/dag.png}  
%\end{figure}

\begin{figure}[H]
	\begin{subfigure}{\textwidth}
	\centering
		\includegraphics[width=0.3\linewidth]{img/dag.png} 
	\end{subfigure}
\end{figure}

As shown in the previous picture, the application is based on a client-server architecture, in which each client, in order to send a \textbf{message} to a \textbf{user}, contacts the main server which is in charge of determining receiver’s physical address and forward the \textbf{message} if it is online.
In the image some typical scenarios are represented to help better understand how \textit{Unisup} works. In particular:
\begin{enumerate}
	\item The message 1 $\xrightarrow{}$ A is sent from the client 1 destined to the client A:  it arrives at the main server that pushes it into the corresponding queue. The client A is online and there is no message to consume on the queue, so it is immediately forwarded.
	\item The message 2 $\xrightarrow{}$ A is sent from the client 2 destined to the client A:  as the previous one, it is pushed into A’s queue but this time the channel is busy. The message will be forwarded as soon as the channel comes idle again.
	\item The message 3 $\xrightarrow{}$ C is sent from client 3 destined to C: again, it is pushed on the correct queue. C is offline, so the message is not forwarded; it will be delivered as soon as C turns online again.
\end{enumerate}	
The OS picture inside clients means that the system works on every OS.
Eventually, the database icon has been added since it is required for mapping clients’ addresses and store chat histories. 


\subsection{Clients}
\subsubsection{Role of the Client}
During the normal usage of the application, the users interact with their client device, so the client is the principal actor of our application.
As described in the use cases analysis user i can register to the application, sign in into his/her account, then he/she can do all the operation of a typical instant-message application like sending/receiving messages and read old messages through clicking on chats. Because the applicative isn’t bound to a specific client, as \textit{Whatsapp} is, a client device can be used by multiple \textbf{users}, they only need to register/login to their account.
From an architectural point of view, the \textbf{client} is only in charge of providing the \textbf{user} a GUI and the communication with the server. The \textbf{client}  device does not store the history of the messages, nor information about the user, but it is in charge of showing chats and messages in the correct natural order that is sorted by ascending timestamp. On client-side, a multithreaded approach has been developed according to the following DAG.

Since SEND A MESSAGE and RECEIVE A MESSAGE are concurrent actions, they are performed by different flows of execution. The only shared data structured is the message list of the relative chat, so the access to it must be synchronized.

\subsubsection{Technologies}
The applicative code runs entirely on the clients: every interaction with the GUI is handled locally and may trigger a send request to the server. The principles technologies used in the client side are JavaFX and Jinterface.
\begin{itemize}
	\item The GUI is implemented using JavaFX classes, some of them were extended for creating ad-hoc classes that can be found in the javafxexstension package. The use of JavaFX is due to make the application more user-friendly.
	\item The Jinterface package provides a set of tools for communication with Erlang processes. In this way the client can send and receive messages to the server, define receive mailboxes and so on.
\end{itemize}

\subsection{The Server}
\subsubsection{Role of the Server}
The server is the core of our system, every client has to communicate with it in order to accomplish any operation of that one’s listed in chapter 2.1.
The server is in charge of:

\begin{itemize}
	\item Register user data at registration time, remembering username and password.
	\item Login users by checking username and password, binding usernames with the physical client process in charge of the receiving of the message.
	\item Forward any message to the correct client: every sender client contacts firstly the server (so that clients are not requested to store physical addresses of other clients, they specify WHAT and not HOW to deliver messages). The server is capable, having as input a username, of determining the relative physical address and forward the message.
	\item Register every in-transit message in order to permit the restoring of the chat list for every client
	\item Queuing correctly the messages that are destined to the same client, so that to handle concurrency and buffering of messages whose receiver is offline. 
\end{itemize}

\subsubsection{Implementation of the Server}
In order to achieve a high-performance application, it is crucial to have a lightweight \textbf{server} code, capable of handling quickly every request and of parallelizing work when possible. As discussed in the paragraph 3.2.1, concurrent actions inside a \textbf{client} are handled by the \textbf{client} itself; the \textbf{server}  is in charge of handling concurrency between different \textbf{clients}. In order to accomplish these requirements, we chose to implement the server entirely in Erlang, so that:
\begin{itemize}
	\item The lightweight of the language is particularly suitable to ensure high performance on the simple actions that the server must perform
	\item The Mnesia persistent support guarantees fast operations and internal handling of concurrent accesses to the data (see par. 3.3.3)
	\item The RabbitMq library queues messages destined to every client with a FIFO policy. It ensures correct concurrency handling and buffering of messages whose receiver is offline.
\end{itemize}
In addition, to improve performance and abstract the \textbf{server} structure, we decided to adopt the \textit{Gen\_Server} behavior to handle \textbf{client} requests.
Moreover, to decrease the coupling between \textbf{client} and the \textbf{server}, a listener module has been provided. At each request it spawns a process that prepares data structures, forward the request to the \textit{Gen\_Server}  after a preliminary pattern matching and finally changes the format of the response in a \textit{client-side-easy-to-parse} way. 


\subsubsection{Persistent Data Storing}
For storing all the information regarding the users and their relative messages we make use of Mnesia. The choice to use Mnesia is driven by the fact that Mnesia is designed with requirements like the following:
\begin{itemize}
	\item Fast real-time key/value lookup
	\item Complicate non-real-time queries mainly for operation and maintenance
	\item High fault tolerance
\end{itemize}
Mnesia is also interesting because of its tight coupling to Erlang, thus almost turning Erlang into a database programming language. This has many benefits, the foremost is that the impedance mismatch between the data format used by the DBMS and the data format used by the programming language, which is used to manipulate the data, completely disappears.

\textit{UniSup} stores the information cited above in two tables named \textit{unisup\_users} and \textit{unisup\_messages} in records made in this way, respectively:
\begin{lstlisting}[language=erlang]
	-record(unisup_messages, {sender,
               receiver,
               text,
               timestamp
              }).

	-record(unisup_users, {username,
                  password,
                  nodeName,
                  pid
                }).
\end{lstlisting}

Because we want to keep the data in a persistent way, so even there is a crash in our server the records shouldn't be lost, the tables are saved using the \textit{disc\_copies} option, thus we maintain the records store in memory and on the disc. Every time the server starts \textit{Mnesia} it waits if the table are present invoking

\begin{lstlisting}[language=erlang]
mnesia:wait_for_tables([unisup_messages, unisup_users], 5000)
\end{lstlisting}
If they are then we simply load them, otherwise we create the tables again.

\subsubsection{Queueing}
To provide the common messaging behavior for our application, we considered using queuing system by exploiting \textit{RabbitMQ}. Each user must have a queue for receiving the messages. Explicitly, each \textbf{user}  is a consumer, and consumes messages from the queue corresponding to his/her username. In this way, we can also manage the synchronization issue related receive a message. The first message comes into the \textit{queues} will be consumed and delivered to the user first, so we have FIFO queues. Since all the communication pass through the server in our application, we need to send the request for consuming to the server when a user gets online. Accordingly, when a user sends a message to another one, the message should be sent to the server and then the server passes it to the receiver queue. Finally, the \textit{queues} must be persistent since we do not want to the not consumed messages when the connection between server and \textit{RabbitMQ} goes down. 
In the following example, user A (Sender) sends a message to \textbf{user} B (Receiver). \textbf{User}  A does not care if the B is online or not.  Request for Consuming will be sent to the server automatically after the B gets online. 

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{img/rabbitMQ.png}  
\end{figure}

\subsubsection{Queueing Architecture}
We used direct exchange of \textit{RabbitMQ} , since our messaging system only contains one to one communication, so we do not consider the possibility of creating channels or groups.
We run a process to handle each user request (sending or consuming). This process adopts \textit{gen\_server} behavior to provide several functionalities to the application. After the initialization, the process would react to one of the following commands:

\begin{enumerate}
	\item \textbf{Reset}: The process will be restarted and re-initialized. 
	\item \textbf{Stop}: The process will be killed, so no more request will be handled. We use this command when stopping the whole server application. 
	\item \textbf{Push}: The input message will be converted to dictionary of binary entries and encoded. Then it will be sent to the receiver queue. If the push was successful, pushed atom will be returned. 
	\item \textbf{Delete User}: The queue of the user will be deleted. 
	\item \textbf{Request Consuming}: When a user sends this request, we must dedicate a channel and consuming process to the user. The channel is required for communication between the consuming process and RabbitMQ, because it connects to the specified queue. The consuming process receives any message from the channel. Then the incoming message will be sent to the user (Receiver) process id.
	\item \textbf{Terminate Consuming}: When the user logouts, we must close its channel. Otherwise, the opening channels may cause the overhead in our server.
\end{enumerate}

In addition, after a certain amount of time (in our case it is thirty minutes), we refreshed the channels by deleting and creating another one. In practice, the heartbeat connection between  \textit{RabbitMQ}  and the server will determine to close the connection after not receiving any data for a certain period. Therefore, we must also check if the connection is dead, recreate the connection and channel again. 

\subsection{Synchronization Management}
\subsubsection{Client-Side}
\subsubsection{Server-Side}

\subsection{Sequence UML Diagrams}

\subsection{Rebar3}
Since our server is implemented in erlang, we realized that we can use Rebar3 to manage our application in proper way. Rebar3 is a build tool and package management for creating and deploying erlang applications [1 – 2]. To use \textbf{amqp} (\textit{RabbitMQ}) and \textbf{jsx} (\textit{JSON}) libraries, we added the dependencies in \textit{Rebar3 config file}, so all of them work under a unified project. To compile and run our server application we simply run the following command

\begin{lstlisting}[language=python]
	$ rebar3 shell --name unisup_server@localhost --setcookie unisup --script src/run\_listener.escript
\end{lstlisting}

